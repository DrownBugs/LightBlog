/*
 Navicat MySQL Data Transfer

 Source Server         : mydbs
 Source Server Type    : MySQL
 Source Server Version : 50527
 Source Host           : localhost:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 50527
 File Encoding         : 65001

 Date: 12/12/2018 21:51:40
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for blog
-- ----------------------------
DROP TABLE IF EXISTS `blog`;
CREATE TABLE `blog`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,
  `title` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `summary` varchar(400) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `create_date` datetime NOT NULL,
  `update_date` datetime NOT NULL,
  `click_count` int(11) NOT NULL,
  `reply_count` int(11) NOT NULL,
  `like_count` int(11) NOT NULL,
  `type_id` int(11) NOT NULL,
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `blog_image` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `reprint` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `type_id`(`type_id`) USING BTREE,
  CONSTRAINT `blog_ibfk_1` FOREIGN KEY (`type_id`) REFERENCES `blog_type` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 312 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of blog
-- ----------------------------
INSERT INTO `blog` VALUES (271, '关于本博客', 'LightBlog—基于ssm的个人博客1.项目简介1.1项目说明本系统是一个轻量级博客系统，前端页面参考了简书，后端管理页面使用了一个网上找的EasyUI管理模板，外观简洁、大气...', '2018-12-09 11:51:09', '2018-12-12 17:18:17', 40, 2, 7, 8, '## Light Blog -- 基于ssm的个人博客\r\n\r\n### 1. 项目简介\r\n\r\n#### 1.1 项目说明\r\n\r\n本系统是一个轻量级博客系统，前端页面参考了[简书](http://www.jianshu.com)，后端管理页面使用了一个网上找的EasyUI管理模板，外观简洁、大气，功能少而完备。\r\n由于本博客系统是博主开发的第一个完整的项目，故会存在代码优化、Bug方面的问题，欢迎大家批评指正。\r\n\r\n#### 1.2 涉及技术及工具\r\n\r\n- 核心框架：SpringMVC、Spring、Mybatis\r\n- 页面框架： EasyUI、Bootstrap\r\n- 富文本编辑器：Editor.md\r\n- 数据库：MySQL\r\n- 项目管理 Maven\r\n- 安全框架 Shiro\r\n\r\n###2. 效果图\r\n\r\n#### 2.1 首页\r\n![](/static/userImage/2018/12/12/0543d8c7-e474-416c-9a04-67e111413943.png)\r\n\r\n![](/static/userImage/2018/12/12/2ec76380-ab24-49c7-a06e-40126fdf4b9b.png)\r\n\r\n#### 2.2 博客阅读页\r\n![](/static/userImage/2018/12/12/020952e2-8d65-4d86-9ff1-05413bc05b25.png)\r\n\r\n![](/static/userImage/2018/12/12/0e233407-175d-4609-a03f-95fa6efbe624.png)\r\n\r\n![](/static/userImage/2018/12/12/fb460853-2e4f-48ed-a90a-bbcbe2d38917.png)\r\n\r\n![](/static/userImage/2018/12/12/46fb1e9f-c8d5-47a3-a608-f4b4607e9146.png)\r\n#### 2.3 后台\r\n![](/static/userImage/2018/12/12/96cdc8c4-f5f3-4d57-8ab5-6922da05d60a.png)\r\n\r\n![](/static/userImage/2018/12/12/918dcfe5-4343-4a6a-ad44-6b0ad6093c38.png)\r\n\r\n![](/static/userImage/2018/12/12/d3b1328d-2e30-43b1-85d8-d615fbd03740.png)\r\n### 3. 构建和运行\r\n\r\n#### 3.1 环境要求\r\n\r\n- JDK：推荐1.8，1.7应该没问题\r\n- Tomcat：推荐Tomcat8，Tomcat7 也行\r\n- MySQL：5.6及以上\r\n\r\n#### 3.2 配置说明\r\n\r\n- **注意**：项目运行要求 Application Context 为 **/** ，不要使用默认的项目名作为根路径（可以直接修改Tomcat配置文件，或把项目置于webapps下的ROOT文件夹中，IDEA 用户可以在 Edit Configuration 下 Deployment 中设置 Application Context）\r\n- 要求MySQL编码为**utf8mb4**（评论或文章中可能会出现utf8不包含的字符）\r\n- 新建数据库，导入lightblog.sql, 并修改resources/resource/db.properties\r\n- 如果想修改About页面显示的内容，请修改resources/resource/resource.properties\r\n- 本博客系统使用了 jquery.cookie.js，cookie默认过期时间为浏览器关闭，若您想重新设定cookie有效时长，可到 /static/js/article.js 总进行修改\r\n- 后台登录用户名和密码均为admin\r\n\r\n### 4. 联系方式\r\n\r\nQQ：2428391347\r\n\r\nEmail： 2428391347@qq.com', '/static/userImage/2018/12/09/2d752f9a-97b7-4984-ac57-84f04bbac0e4.jpg', '');
INSERT INTO `blog` VALUES (299, 'CSDN如何转载别人的文章', '对于喜欢逛CSDN的人来说，看别人的博客确实能够对自己有不小的提高，有时候看到特别好的博客想转载下载，但是不能一个字一个字的敲了，这时候我们就想快速转载别人的博客，把别人的博客移到...', '2018-12-11 14:32:00', '2018-12-12 17:00:17', 8, 1, 2, 8, '<svg xmlns=\"http://www.w3.org/2000/svg\" style=\"display: none;\"><path stroke-linecap=\"round\" d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path></svg>\r\n<p>  对于喜欢逛CSDN的人来说，看别人的博客确实能够对自己有不小的提高，有时候看到特别好的博客想转载下载，但是不能一个字一个字的敲了，这时候我们就想快速转载别人的博客，把别人的博客移到自己的空间里面，当然有人会说我们可以收藏博客啊，就不需要转载，(⊙o⊙)… 也对。。</p>\r\n\r\n<h2 id=\"实现\"><a target=\"_blank\"></a><a target=\"_blank\"></a>实现</h2>\r\n\r\n<p>  因为我自己当初想转载的时候却不知道该怎么转载，所以学会了之后就把方法写出来，帮助那些想转载却不知道该怎么转载的人（大神勿笑）。 <br>\r\n  我们首先打开要转载的博客，然后鼠标右键就会出现下面的菜单： <br>\r\n</p><center><img src=\"/static/userImage/2018/12/11/889ce525-b577-47f4-ba95-894a35d77bb0.jpg\" alt=\"这里写图片描述\" title=\"\"></center> <br>\r\n  我们点击【审查元素】，就会出现当前HTML页面的代码，如下：<p></p>\r\n\r\n<p></p><center><img src=\"/static/userImage/2018/12/11/4a8c0a71-9e5d-49c2-beac-0c1c9ce84068.png\" width=\"548\" height=\"353\"> </center> <br>\r\n  我们选中“article_content”从图片左边我们也可以看到，博客的内容已经被我们选中了，也就是我们想要转载的内容，然后右键，就会出现下面的菜单：<p></p>\r\n\r\n<p></p><center><img src=\"/static/userImage/2018/12/11/7f508b42-2a65-48ef-8e42-88663e0160e1.png\" alt=\"这里写图片描述\" title=\"\"></center> <br>\r\n我们选中【Copy as HTML】就可以把其中要转载的内容复制下来，接下来的就是粘贴了。 <br>\r\n  我们先新建一篇文章，打开markdown编辑器（因为在普通的编辑器我没有找到方法/(ㄒoㄒ)/~~），然后粘贴一下，就会出现下面的内容：<p></p>\r\n\r\n<p></p><center><img src=\"/static/userImage/2018/12/11/1b0ef8e7-3799-4b0e-bd6f-0bcb46e86386.png\" width=\"762\" height=\"388\"></center> <br>\r\n  可以在右边看到，博客内容已经被转载了，然后发表就可以了。<p></p>\r\n\r\n<p>  <font color=\"red\">最后特别要注意的是，我们发表的时候一定要选择【转载】，尊重原创！！</font></p>', NULL, 'https://blog.csdn.net/bolu1234/article/details/51867099');
INSERT INTO `blog` VALUES (301, 'Java 之 BASE64 加密解密', '背景在给邮件发送URL链接找回密码时，会发送一个链接，像这样http://localhost:8080/resetpass?sid=c1b55b980db4eb74a4264a92...', '2018-12-11 16:47:53', '2018-12-12 16:59:20', 2, 0, 2, 5, '# 背景\r\n\r\n在给邮件发送 URL 链接找回密码时，会发送一个链接，像这样\r\n\r\nhttp://localhost:8080/resetpass?sid=c1b55b980db4eb74a4264a92d53cd953&account=saysky\r\n\r\n验证原理就是，当用户点击链接，然后请求 控制器里的 resetpass 方法，获得 sid(密钥) 和 account(用户名) 两个参数。根据用户名去数据库中的 “邮件找回密码” 表(mail_retrieve)里寻找记录，获得 mailRetrieve 对象，然后比较 参数中的 sid 和 mailRetrieve.getSid() 即可，当然也可以加一个outtimes 超时时间 字段。\r\n\r\n如上链接，sid 是经过 MD5 加密，并且无需解密，只需要比较参数dis和数据库sid是否相等，而account 用户名一定要传过去，目前是直接明文显示，感觉不是特别好，所以这里需要给 accout 也加密一下比较好。然后在 控制器里接受参数的时候，然后在解密即可。\r\n\r\n目标是，无需太复杂，肉眼无法识别即可，但求效率高。\r\n# BASE64 加密解码\r\n```java\r\npackage com.liuyanzhao.chuyun.util;\r\nimport sun.misc.BASE64Decoder;\r\nimport sun.misc.BASE64Encoder;\r\nimport java.io.UnsupportedEncodingException;\r\n/**\r\n * @author 言曌\r\n * @date 2018/2/24 上午11:45\r\n */\r\npublic class Base64Util {\r\n    /**\r\n     * 加密\r\n     * @param str\r\n     * @return\r\n     */\r\n    @SuppressWarnings(\"restriction\")\r\n    public static String encode(String str) {\r\n        byte[] b = null;\r\n        String s = null;\r\n        try {\r\n            b = str.getBytes(\"utf-8\");\r\n        } catch (UnsupportedEncodingException e) {\r\n            e.printStackTrace();\r\n        }\r\n        if (b != null) {\r\n            s = new BASE64Encoder().encode(b);\r\n        }\r\n        return s;\r\n    }\r\n    /**\r\n     * 解密\r\n     * @param s\r\n     * @return\r\n     */\r\n    @SuppressWarnings(\"restriction\")\r\n    public static String decode(String s) {\r\n        byte[] b = null;\r\n        String result = null;\r\n        if (s != null) {\r\n            BASE64Decoder decoder = new BASE64Decoder();\r\n            try {\r\n                b = decoder.decodeBuffer(s);\r\n                result = new String(b, \"utf-8\");\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    public static void main(String args[]) {\r\n        Long startTime = System.currentTimeMillis();\r\n        String rawString = \"loveluoqi\";\r\n        String encodedString = encode(rawString);\r\n        String decodedString = decode(encodedString);\r\n        System.out.println(rawString);\r\n        System.out.println(encodedString);\r\n        System.out.println(decodedString);\r\n        Long endTime = System.currentTimeMillis();\r\n        System.out.println(\"总共耗时毫秒数：\" + (endTime - startTime));\r\n    }\r\n}\r\n```\r\n运行结果如下\r\n![](/static/userImage/2018/12/11/e009e819-3fc2-4289-99e1-431fa057ce9b.png)', NULL, 'https://liuyanzhao.com/7578.html');
INSERT INTO `blog` VALUES (302, 'JAVA 对象的序列化', '下面将介绍对象的序列化——一种将对象转成字节方便传送到别处或存储在硬盘上，并且再从转化成的字节重构对象的机制。序列化是分布式管理必备的工具，分布式处理中将对象从一个虚拟传到另一个虚...', '2018-12-11 17:12:41', '2018-12-11 17:16:00', 2, 0, 2, 5, '　　下面将介绍对象的序列化——一种将对象转成字节方便传送到别处或存储在硬盘上，并且再从转化成的字节重构对象的机制。\r\n\r\n　　序列化是分布式管理必备的工具，分布式处理中将对象从一个虚拟传到另一个虚拟机。序列化也被用于故障转移和负载均衡方面，序列化对象可以从一个服务器移到另一个服务器。如果你开发过服务器端软件，就会经常需要序列化。下面介绍如何序列化。(摘自 《Core Java》)\r\n  \r\n  ## 一、简单的一个例子\r\n  \r\n  Person.java\r\n  \r\n  ```java\r\nimport java.io.Serializable;\r\n\r\npublic class Person implements Serializable {\r\n    private String name;\r\n    private int age;\r\n    private String sex;\r\n    public Person(String name, int age, String sex) {\r\n        this.name = name;\r\n        this.age = age;\r\n        this.sex = sex;\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return \"Person{\" +\r\n                \"name=\'\" + name + \'\\\'\' +\r\n                \", age=\" + age +\r\n                \", sex=\'\" + sex + \'\\\'\' +\r\n                \'}\';\r\n    }\r\n}\r\n  ```\r\n  \r\n  TestObjSerializeAndDeserialize.java\r\n  \r\n  ```java\r\nimport java.io.*;\r\n\r\npublic class TestObjSerializeAndDeserialize {\r\n    public static void main(String[] args) throws Exception {\r\n        //1、序列化Person对象\r\n        SerializePerson();\r\n        //2、反序列Person对象\r\n        Person p = DeserializePerson();\r\n        System.out.println(p);\r\n    }\r\n    /**\r\n     * 序列化\r\n     * @throws FileNotFoundException\r\n     * @throws IOException\r\n     */\r\n    private static void SerializePerson() throws FileNotFoundException, IOException {\r\n        Person person = new Person(\"言曌\",18,\"男\");\r\n        // ObjectOutputStream 对象输出流，将Person对象存储到指定路径下的Person.txt文件中，完成对Person对象的序列化操作\r\n        ObjectOutputStream oo = new ObjectOutputStream(new FileOutputStream(new File(\"/Users/liuyanzhao/Desktop/temp/Person.txt\")));\r\n        oo.writeObject(person);\r\n        System.out.println(\"Person对象序列化成功！\");\r\n        oo.close();\r\n    }\r\n    /**\r\n     * 反序列化\r\n     * @return\r\n     * @throws Exception\r\n     * @throws IOException\r\n     */\r\n    private static Person DeserializePerson() throws Exception, IOException {\r\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(\"/Users/liuyanzhao/Desktop/temp/Person.txt\")));\r\n        Person person = (Person) ois.readObject();\r\n        System.out.println(\"Person对象反序列化成功！\");\r\n        return person;\r\n    }\r\n}\r\n  ```\r\n  \r\n  1、我们可以先注释掉 main 方法里的反序列化的那两行代码，先执行序列化。然后就可以在指定目录，看到一个刚才创建的 Person.txt 文件。\r\n  使用 Sublime 打开以下\r\n  \r\n  >   aced 0005 7372 0006 5065 7273 6f6e 6299\r\n	  e8ea 3077 30c4 0200 0349 0003 6167 654c\r\n	  0004 6e61 6d65 7400 124c 6a61 7661 2f6c\r\n	  616e 672f 5374 7269 6e67 3b4c 0003 7365\r\n	  7871 007e 0001 7870 0000 0012 7400 06e8\r\n	  a880 e69b 8c74 0003 e794 b7\r\n一堆十六进制编码。\r\n\r\n2、然后注释掉序列化对象部分，运行反序列化部分。\r\n运行效果图如下\r\n![](http://localhost:8081/static/userImage/2018/12/11/97314255-f173-4891-b781-615be6434df1.png)\r\n\r\n## 二、为什么要手动设置 serialVersionUID\r\n\r\n通常我们有时候在 Person 类里不写\r\n\r\n>   private static final long serialVersionUID = 1L;\r\n	\r\n也能正常序列化和反序列化。\r\n\r\n因为系统会自带帮我们创建一个 serialVersionUID。\r\n\r\n下面测试一个例子，不设置 serialVersionUID ，当对象信息改变的时候，会出现什么状况。\r\n\r\n \r\n\r\n1、先把序列化的那行注释掉，不进行序列化操作。使用刚才生成的 Person.txt\r\n\r\n2、在 Person 里添加一个属性 phone\r\n\r\n3、运行反序列化，会报一个异常\r\n\r\n> Exception in thread \"main\" java.io.InvalidClassException: Person; local class incompatible: stream classdesc serialVersionUID = 899743677678844260, local class 	serialVersionUID = -2823344428596659768\r\nat java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:616)\r\nat java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1843)\r\nat java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1713)\r\nat java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2000)\r\nat java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1535)\r\nat java.io.ObjectInputStream.readObject(ObjectInputStream.java:422)\r\nat TestObjSerializeAndDeserialize.DeserializePerson(TestObjSerializeAndDeserialize.java:43)\r\nat TestObjSerializeAndDeserialize.main(TestObjSerializeAndDeserialize.java:15)\r\n\r\n因为在序列化的时候，将对象写入文件的时候，会写入类名和所有实例变量的名称和值。\r\n\r\n其中 serialVersionUID 因为没有设置默认值，系统会自动根据哈希值生成一个。如果类的实现发生改变，那么 serialVersionUID 也会发生改变。\r\n\r\n \r\n\r\n相反，如果我们在序列化之前加上\r\n\r\n>	private static final long serialVersioLnUID = 1L;\r\n\r\n \r\n\r\n然后序列化，然后给 Person 类加上一个 phone 字段。\r\n\r\n这时候就不会报异常了。\r\n\r\n![](http://localhost:8081/static/userImage/2018/12/11/0239be42-3cd8-47be-8eb5-7c3355ca26e3.png)\r\n\r\n至于 serialVersioLnUID 等于几并不重要，但是该属性的修饰和类型必须为 final long。\r\n\r\n## 三、使用 transient 标记不需要序列化的字段\r\n\r\n有些实例变量是不需要序列化的——例如当一个对象保留缓存值的时候，一般也不需要序列化该缓存值，重新计算缓存值而不是存储缓存值可能更好。\r\n\r\n为了实现某些实例变量不序列化，简单的方法就是给这个变量添加一个 transient 修饰符，打过 transient 标记的字段在序列化的时候就会背忽略。\r\n\r\nPerson.java\r\n\r\n```java\r\nimport java.io.Serializable;\r\n\r\npublic class Person implements Serializable {\r\n    private static final long serialVersioLnUID = 1L;\r\n    private String name;\r\n    private transient int age;\r\n    private  String sex;\r\n    private transient String phone;\r\n    public Person(String name, int age, String sex, String phone) {\r\n        this.name = name;\r\n        this.age = age;\r\n        this.sex = sex;\r\n        this.phone = phone;\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return \"Person{\" +\r\n                \"name=\'\" + name + \'\\\'\' +\r\n                \", age=\" + age +\r\n                \", sex=\'\" + sex + \'\\\'\' +\r\n                \", phone=\'\" + phone + \'\\\'\' +\r\n                \'}\';\r\n    }\r\n}\r\n```\r\n\r\n进行序列化和反序列化，效果图如下\r\n\r\n![](http://localhost:8081/static/userImage/2018/12/11/7ea22895-d64f-4cdd-bd02-d4d04b2e7f58.png)\r\n\r\n其中 age 和 phone 是没有被序列化的，所有反序列化的时候也是没有值的。因为 age 是 int 类型，默认值是 0，而 phone 是 String 类型的，默认是 null。\r\n\r\n>  参考：《Core Java for the Impatient》', '/static/userImage/2018/12/11/63f39dc2-e40c-47b0-91e8-aa1f8f5d1cf3.jpg', 'https://liuyanzhao.com/7649.html');
INSERT INTO `blog` VALUES (303, '图解排序算法(四)之归并排序', '基本思想归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问...', '2018-12-11 17:22:38', '2018-12-12 16:58:49', 3, 0, 1, 10, '## 基本思想\r\n\r\n　　归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案\"修补\"在一起，即分而治之)。\r\n  \r\n### 分而治之\r\n\r\n![](/static/userImage/2018/12/11/9df9962f-5578-41cc-8693-c10fa245e566.png)\r\n\r\n可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。\r\n\r\n## 合并相邻有序子序列\r\n\r\n　　再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。\r\n  \r\n  ![](/static/userImage/2018/12/11/8df24a58-df9a-4406-b2e2-c66dd79aa372.png)\r\n  \r\n## 代码实现\r\n\r\n```java\r\npackage sortdemo;\r\n\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * Created by chengxiao on 2016/12/8.\r\n */\r\npublic class MergeSort {\r\n    public static void main(String []args){\r\n        int []arr = {9,8,7,6,5,4,3,2,1};\r\n        sort(arr);\r\n        System.out.println(Arrays.toString(arr));\r\n    }\r\n    public static void sort(int []arr){\r\n        int []temp = new int[arr.length];//在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间\r\n        sort(arr,0,arr.length-1,temp);\r\n    }\r\n    private static void sort(int[] arr,int left,int right,int []temp){\r\n        if(left<right){\r\n            int mid = (left+right)/2;\r\n            sort(arr,left,mid,temp);//左边归并排序，使得左子序列有序\r\n            sort(arr,mid+1,right,temp);//右边归并排序，使得右子序列有序\r\n            merge(arr,left,mid,right,temp);//将两个有序子数组合并操作\r\n        }\r\n    }\r\n    private static void merge(int[] arr,int left,int mid,int right,int[] temp){\r\n        int i = left;//左序列指针\r\n        int j = mid+1;//右序列指针\r\n        int t = 0;//临时数组指针\r\n        while (i<=mid && j<=right){\r\n            if(arr[i]<=arr[j]){\r\n                temp[t++] = arr[i++];\r\n            }else {\r\n                temp[t++] = arr[j++];\r\n            }\r\n        }\r\n        while(i<=mid){//将左边剩余元素填充进temp中\r\n            temp[t++] = arr[i++];\r\n        }\r\n        while(j<=right){//将右序列剩余元素填充进temp中\r\n            temp[t++] = arr[j++];\r\n        }\r\n        t = 0;\r\n        //将temp中的元素全部拷贝到原数组中\r\n        while(left <= right){\r\n            arr[left++] = temp[t++];\r\n        }\r\n    }\r\n}\r\n```\r\n执行结果\r\n>	[1, 2, 3, 4, 5, 6, 7, 8, 9]\r\n\r\n## 最后\r\n\r\n　　归并排序是稳定排序，它也是一种十分高效的排序，能利用完全二叉树特性的排序一般性能都不会太差。java中Arrays.sort()采用了一种名为TimSort的排序算法，就是归并排序的优化版本。从上文的图中可看出，每次合并操作的平均时间复杂度为O(n)，而完全二叉树的深度为|log2n|。总的平均时间复杂度为O(nlogn)。而且，归并排序的最好，最坏，平均时间复杂度均为O(nlogn)。', '/static/userImage/2018/12/11/0f228359-0fe7-4cbe-b6d8-06e57a91f1e7.png', 'http://www.cnblogs.com/chengxiao/p/6194356.html');
INSERT INTO `blog` VALUES (304, 'Oracle约束(Constraint)详解', '概述约束是数据库用来确保数据满足业务规则的手段，不过在真正的企业开发中，除了主键约束这类具有强需求的约束，像外键约束，检查约束更多时候仅仅出现在数据库设计阶段，真实环境却很少应用，...', '2018-12-11 17:47:07', '2018-12-11 17:54:19', 3, 0, 1, 9, '## 概述\r\n\r\n　　约束是数据库用来确保数据满足业务规则的手段，不过在真正的企业开发中，除了主键约束这类具有强需求的约束，像外键约束，检查约束更多时候仅仅出现在数据库设计阶段，真实环境却很少应用，更多是放到程序逻辑中去进行处理。这也比较容易理解，约束会一定程度上较低数据库性能，有些规则直接在程序逻辑中处理就可以了，同时，也有可能在面对业务变更或是系统扩展时，数据库约束会使得处理不够方便。不过在我看来，数据库约束是保证数据准确性的最后一道防线，对于设计合理的系统，处于性能考虑数据库约束自然可有可无；不过若是面对关联关系较为复杂的系统，且对系统而言，数据的准确性完整性要高于性能要求，那么这些约束还是有必要的（否则，就会出现各种相对业务规则来说莫名其妙的脏数据，本人可是深有体会的。。）。总之，对于约束的选择无所谓合不合理，需要根据业务系统对于准确性和性能要求的侧重度来决定。\r\n  \r\n  数据库约束有五种：\r\n  - 主键约束（PRIMARY KEY）\r\n  -  唯一性约束（UNIQUE)\r\n  -  非空约束（NOT NULL)\r\n  -  外键约束（FOREIGN KEY)\r\n  -  检查约束（CHECK)\r\n  \r\n下面我们就分别来看下这五类约束：\r\n\r\n## 数据库约束\r\n\r\n### 主键约束（PRIMARY KEY)\r\n\r\n　　主键是定位表中单个行的方式，可唯一确定表中的某一行，关系型数据库要求所有表都应该有主键，不过Oracle没有遵循此范例要求，Oracle中的表可以没有主键（这种情况不多见）。关于主键有几个需要注意的点：\r\n  \r\n  1. 键列必须必须具有唯一性，且不能为空，其实主键约束 相当于 UNIQUE+NOT NULL\r\n  2. 一个表只允许有一个主键\r\n  3. 主键所在列必须具有索引（主键的唯一约束通过索引来实现），如果不存在，将会在索引添加的时候自动创建\r\n \r\n\r\n　　添加主键（约束的添加可在建表时创建，也可如下所示在建表后添加，一般推荐建表后添加，灵活度更高一些，建表时添加某些约束会有限制）\r\n  \r\n>	SQL> alter table emp add constraint emp_id_pk primary key(id);\r\n\r\n### 唯一性约束（UNIQUE)\r\n\r\n唯一性约束可作用在单列或多列上，对于这些列或列组合，唯一性约束保证每一行的唯一性。\r\nUNIQUE需要注意：\r\n1.  对于UNIQUE约束来讲，索引是必须的。如果不存在，就自动创建一个（UNIQUE的唯一性本质上是通过索引来保证的）\r\n2.  UNIQUE允许null值，UNIQUE约束的列可存在多个null。这是因为，Unique唯一性通过btree索引来实现，而btree索引中不包含null。当然，这也造成了在where语句中用null值进行过滤会造成全表扫描。\r\n\r\n添加唯一约束\r\n>	SQL> alter table emp add constraint emp_code_uq unique(code);\r\n\r\n### 非空约束（NOT NULL)\r\n\r\n非空约束作用的列也叫强制列。顾名思义，强制键列中必须有值，当然建表时候若使用default关键字指定了默认值，则可不输入。\r\n\r\n添加非空约束，语法较特别\r\n>	SQL> alter table emp modify ename not null;\r\n\r\n### 外键约束（FOREIGN KEY）\r\n\r\n　　外键约束定义在具有父子关系的子表中，外键约束使得子表中的列对应父表的主键列，用以维护数据库的完整性。不过出于性能和后期的业务系统的扩展的考虑，很多时候，外键约束仅出现在数据库的设计中，实际会放在业务程序中进行处理。外键约束注意以下几点：\r\n  \r\n1. 外键约束的子表中的列和对应父表中的列数据类型必须相同，列名可以不同\r\n2. 对应的父表列必须存在主键约束（PRIMARY KEY）或唯一约束（UNIQUE）\r\n3. 外键约束列允许NULL值，对应的行就成了孤行了\r\n\r\n　　其实很多时候不使用外键，很多人认为会让删除操作比较麻烦，比如要删除父表中的某条数据，但某个子表中又有对该条数据的引用，这时就会导致删除失败。我们有两种方式来优化这种场景：\r\n\r\n　　第一种方式简单粗暴，删除的时候，级联删除掉子表中的所有匹配行，在创建外键时，通过 on delete cascade 子句指定该外键列可级联删除：\r\n  \r\n>	SQL> alter table emp add constraint emp_deptno_fk foreign key(deptno) references dept (deptno) on delete cascade;\r\n\r\n第二种方式，删除父表中的对应行，会将对应子表中的所有匹配行的外键约束列置为NULL，通过 on delete set null 子句实施：\r\n\r\n>	SQL> alter table emp add constraint emp_deptno_fk foreign key(deptno) references dept(deptno) on delete set null;\r\n\r\n　　实际上，外键约束列和对应的父表列可以在同一张表中，常见的就是表的业务逻辑含义是一棵树，最简单的例子如下（id为主键id，fid为父id，fid存储对id的引用），这种结构的表根据业务要求可通过Oracle的递归查询来获取这种层级关系\r\n  \r\n  ![](http://localhost:8081/static/userImage/2018/12/11/7d820bdb-a8b1-49b6-9d17-153c564ea3cc.png)\r\n  \r\n ### 检查约束（CHECK)\r\n \r\n 检查约束可用来实施一些简单的规则，比如列值必须在某个范围内。检查的规则必须是一个结果为true或false 的表达式，比如：\r\n \r\n >	SQL> alter table emp add constraint emp_sex_ck check(sex in(\'男\',\'女\'));\r\n \r\n ## 约束状态\r\n \r\n　　很多时候由于业务需要，比如我们有大量的历史数据，需要和现有数据合并，当前表存在数据库约束（如非空约束），而这些历史数据又包含违背非空约束的数据行，为了避免导入时由于违反约束而导入失败，我们通过调整约束状态来达到目的。\r\n  \r\n  数据库约束有两类状态\r\n  \r\n**启用/禁用**（*enable/disable*）：是否对新变更的数据启用约束验证\r\n\r\n**验证/非验证** (*validate/novalidate*) ：是否对表中已客观存在的数据进行约束验证\r\n\r\n这两类四种状态从语法角度讲可以随意组合，默认是 *enable validate*\r\n\r\n下面我们来看着四类组合会分别出现什么样的效果：\r\n\r\n- *enable validate* : 默认的约束组合状态，无法添加违反约束的数据行，数据表中也不能存在违反约束的数据行；\r\n- *enable novalidate* : 无法添加违反约束的数据行，但对已存在的违反约束的数据行不做验证；\r\n- *disable validate* : 可以添加违反约束的数据行，但对已存在的违反约束的数据行会做约束验证（从描述中可以看出来，这本来就是一种相互矛盾的约束组合，只不过是语法上支持这种组合罢了，造成的结果就是会导致DML失败）\r\n- *disable novalidate* : 可以添加违法约束的数据行，对已存在的违反约束的数据行也不做验证。\r\n\r\n拿上面的例子来说，我们需要上传大量违反非空约束的历史数据（从业务角度讲这些数据不会造成系统功能异常），可以临时将约束状态转为 disable novalidate，以保证这些不合要求的数据导入表中\r\n>	SQL> alter table emp modify constraint emp_ename_nn disable novalidate;\r\n\r\n在数据导入完成之后，我们再将约束状态转为enable novalidate 以确保之后添加的数据不会再违反约束\r\n>	SQL> alter table emp modify constraint emp_ename_nn enable novalidate;\r\n\r\n## 总结\r\n\r\n　　本文介绍了数据库中的五类约束，也提到了数据库约束的四种状态组合，当你由于业务需求或是系统扩展，在一个约束严苛的系统中由于约束限制频繁操作失败的时候，不同组合的约束状态或许能给你另一种处理方案。谢谢支持。', '/static/userImage/2018/12/11/fad2df09-f4a2-4cea-bb5a-2b90d40ab69b.png', 'https://www.cnblogs.com/chengxiao/p/6032183.html');
INSERT INTO `blog` VALUES (305, 'Java之美[从菜鸟到高手演练]之Linux篇——Linux下JDK、Ruby、Node.js等runtime的安装', '我们常常工作在Linux下，所以必须要学会安装这些常用的runtime，这些工作都是相通的，学会一种，其他的举一反三就OK了！一般来说，有三种方法：使用包管理器，像ruby的rvm...', '2018-12-11 22:44:13', '2018-12-11 22:44:13', 3, 0, 2, 7, '我们常常工作在Linux下，所以必须要学会安装这些常用的runtime，这些工作都是相通的，学会一种，其他的举一反三就OK了！\r\n\r\n一般来说，有三种方法：\r\n1. 使用包管理器，像ruby的rvm（推荐）\r\n2. 直接安装二进制包\r\n3. 从源码包进行编译安装\r\n\r\n三种方法都比较简单，除了安装步骤外，还有一个重要的步骤就是在安装完后配置环境变量。下面我举例说明下：\r\n\r\n**Linux下安装Java**\r\n\r\nJava的安装不需要使用特定的包管理器，直接在Oracle官网上下载二进制包，形如：jdk-7u17-linux-x64.tar.gz解压后得到一个文件夹，将该文件夹拷贝到你要安装的目录下就可以了，接下来就是一点配置：（如我们将上述文件放在/opt下）\r\n\r\nroot权限打开/etc/profile文件，在末尾加上：\r\n\r\n>	\r\nJAVA_HOME=/opt/jdk1.7.17\r\nPATH=$JAVA_HOME/bin:$PATH\r\nCLASSPATH=.:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar\r\nexport JAVA_HOME PATH CLASSPATH\r\n\r\n执行.  /etc/profile可使profile修改后立即生效。(注意.后面的空格)\r\n\r\n其实这段配置的目的就是设置PATH和CLASSPATH，与我们在windows下设置环境变量是一致的。之后用javac或者java -version测试下，看成功没有。\r\n\r\n**Linux下Ruby的安装：**\r\n\r\n1、采用包管理器(rvm)安装\r\n\r\n>	Install curl using apt-get\r\nsudo apt-get install curl\r\nInstall rvm using curl\r\ncurl -L https://get.rvm.io | bash -s\r\nReload the .bash_profile in the current terminal\r\nsource ~/.bash_profile\r\nNote : To make sure bash is run as a login shell and rvm is loaded, please follow the steps in the doc Integrating RVM with gnome-terminal\r\nCheck the required dependencies for installing ruby\r\nrvm requirements\r\nInstall the required pre-reqs for installing ruby\r\nsudo /usr/bin/apt-get install build-essential bison openssl libreadline6 libreadline6-dev curl git-core zlib1g \\zlib1g-dev libssl-dev libyaml-dev libsqlite3-0 libsqlite3-dev sqlite3 libxml2-dev libxslt-dev autoconf \\ libc6-dev ncurses-dev\r\nInstall ruby 1.9.2 using rvm\r\nrvm install 1.9.2\r\nSet the ruby version to 1.9.2\r\nrvm use 1.9.2\r\nCheck that the correct version of ruby has been set\r\nruby -v\r\nInstall bundler gem\r\ngem install bundler\r\nInstall rake gem\r\ngem install rake\r\n\r\n**2、下载二进制包直接解压安装**\r\n\r\n和上文中Java的安装方法一样，下载形如ruby-1.9.3-p0.tar.gz，解压，配置环境变量就OK了。\r\n\r\n**3、源码编译安装**\r\n\r\n下载源码，解压后，进入目录，直接执行：\r\n\r\n>	./configure –prefix=/usr/local/ruby  （=/usr/local/ruby  为将要安装ruby的目录）\r\nmake && make install', NULL, 'https://blog.csdn.net/zhangerqing/article/details/8609178');
INSERT INTO `blog` VALUES (306, 'Java之美[从菜鸟到高手演练]之Linux篇——压缩及解压缩命令tar的使用', '这些命令使用很常见，我们需要长记在心，直接总结下吧：tar[-cxtzjvfpPN]文件与目录….参数：-c：建立一个压缩文件的参数指令-x：解开一个压缩文件的参数指令-t：查看压...', '2018-12-11 22:56:38', '2018-12-11 23:00:46', 3, 0, 1, 7, '这些命令使用很常见，我们需要长记在心，直接总结下吧：\r\ntar [-cxtzjvfpPN] 文件与目录 ....\r\n\r\n参数：\r\n-c ：建立一个压缩文件的参数指令\r\n-x ：解开一个压缩文件的参数指令\r\n-t ：查看压缩文件里面的文件\r\n\r\n**特别注意：** c/x/t 同时只能存在一个，原因是我们不可能同时压缩与解压缩。\r\n\r\n-z ：是否同时具有 gzip 的属性？亦即是否需要用 gzip 压缩\r\n-j ：是否同时具有 bzip2 的属性？亦即是否需要用 bzip2 压缩\r\n-v ：压缩的过程中显示文件！这个常用，但不建议用在背景执行过程\r\n-f ： 使用档名，请留意，在 f 之后要立即接档名喔！不要再加参数\r\n　　　例如使用『 tar -zcvfP tfile sfile』就是错误的写法，要写成\r\n　　　『 tar -zcvPf tfile sfile』才对喔！\r\n-p ：使用原文件的原来属性（属性不会依据使用者而变）\r\n-P ：可以使用绝对路径来压缩！\r\n-N ：比后面接的日期(yyyy/mm/dd)还要新的才会被打包进新建的文件中！\r\n--exclude FILE：在压缩的过程中，不要将 FILE 打包！\r\n\r\n#### 范例：\r\n\r\n##### 范例一：将整个 /etc 目录下的文件全部打包成为 /tmp/etc.tar\r\n\r\n>	[root@linux ~]# tar -cvf /tmp/etc.tar /etc<==仅打包，不压缩！\r\n[root@linux ~]# tar -zcvf /tmp/etc.tar.gz /etc<==打包后，以 gzip 压缩\r\n[root@linux ~]# tar -jcvf /tmp/etc.tar.bz2 /etc<==打包后，以 bzip2 压缩\r\n\r\n特别注意，在参数 f 之后的文件档名是自己取的，我们习惯上都用 .tar 来作为辨识。\r\n如果加 z 参数，则以 .tar.gz 或 .tgz 来代表 gzip 压缩过的 tar file ～\r\n如果加 j 参数，则以 .tar.bz2 来作为附档名啊～\r\n上述指令在执行的时候，会显示一个警告讯息：『tar: Removing leading \'/\" from member names』那是关於绝对路径的特殊设定。\r\n\r\n##### 范例二：查阅上述 /tmp/etc.tar.gz 文件内有哪些文件\r\n\r\n>	[root@linux ~]# tar -ztvf /tmp/etc.tar.gz\r\n\r\n由於我们使用 gzip 压缩，所以要查阅该 tar file 内的文件时，就得要加上 z 这个参数了！这很重要的！\r\n\r\n##### 范例三：将 /tmp/etc.tar.gz 文件解压缩在 /usr/local/src 底下\r\n\r\n>	[root@linux ~]# cd /usr/local/src\r\n[root@linux src]# tar -zxvf /tmp/etc.tar.gz\r\n\r\n在预设的情况下，我们可以将压缩档在任何地方解开的！\r\n以这个范例来说，我先将工作目录变换到 /usr/local/src 底下，\r\n并且解开 /tmp/etc.tar.gz ，则解开的目录会在 /usr/local/src/etc 呢！\r\n另外，如果您进入 /usr/local/src/etc则会发现，该目录下的文件属性与 /etc/ 可能会有所不同喔！\r\n\r\n##### 范例四：在 /tmp 底下，我只想要将 /tmp/etc.tar.gz 内的 etc/passwd 解开而已\r\n\r\n>	[root@linux ~]# cd /tmp\r\n[root@linux tmp]# tar -zxvf /tmp/etc.tar.gz etc/passwd\r\n\r\n我可以透过 tar -ztvf 来查阅 tarfile 内的文件名称，\r\n如果单只要一个文件，就可以透过这个方式来下达！\r\n注意到！ etc.tar.gz 内的根目录 / 是被拿掉了！\r\n\r\n##### 范例五：将 /etc/ 内的所有文件备份下来，并且保存其权限！\r\n\r\n>	[root@linux ~]# tar -zcvpf /tmp/etc.tar.gz /etc \r\n\r\n 这个 -p 的属性是很重要的，尤其是当您要保留原本文件的属性时！\r\n \r\n##### 范例六：在 /home 当中，比 2005/06/01 新的文件才备份\r\n\r\n>	[root@linux ~]# tar -N \"2005/06/01\" -zcvf home.tar.gz /home\r\n\r\n##### 范例七：我要备份 /home, /etc ，但不要 /home/dmtsai\r\n\r\n>	[root@linux ~]# tar --exclude /home/dmtsai -zcvf myfile.tar.gz /home/* /etc\r\n\r\n##### 范例八：将 /etc/ 打包后直接解开在 /tmp 底下，而不产生文件！\r\n\r\n>	[root@linux ~]# cd /tmp\r\n[root@linux tmp]# tar -cvf - /etc | tar -xvf -\r\n\r\n这个动作有点像是 cp -r /etc /tmp 啦～依旧是有其有用途的！\r\n要注意的地方在於输出档变成 - 而输入档也变成 - ，又有一个 | 存在～\r\n这分别代表 standard output, standard input 与管线命令啦！\r\n这部分我们会在 Bash shell 时，再次提到这个指令跟大家再解释啰！\r\n\r\n#### 常用压缩解压缩命令：\r\n\r\n后缀 .tar\r\n解压命令: tar xvf InFile.tar\r\n压缩命令: tar cvf OutFile.tar InFile\r\n可压缩文件类型: 文件夹\r\n\r\n后缀 .tar.gz\r\n解压命令: tar zxvf InFile.tar.gz\r\n压缩命令: tar zcvf OutFile.tar.gz InFile\r\n可压缩文件类型: 文件夹\r\n\r\n后缀 .tar.bz2\r\n解压命令: tar jxvf InFile.tar.bz2\r\n压缩命令: tar jcvf OutFile.tar.bz2 InFile\r\n可压缩文件类型: 文件夹\r\n\r\n\r\n后缀 .tar.Z\r\n解压命令: tar Zxvf InFile.tar.Z\r\n压缩命令: tar Zcvf OutFile.tar.Z InFile\r\n可压缩文件类型: 文件夹\r\n\r\n\r\n后缀 .gz\r\n解压命令: gzip -d InFile.gz 或 gunzip InFile.gz\r\n压缩命令: gzip InFile\r\n可压缩文件类型: 普通文件/打包文件\r\n\r\n\r\n后缀 .zip\r\n解压命令: unzip InFile.zip\r\n压缩命令: zip OutFile.zip InFile\r\n可压缩文件类型: 普通文件列表/打包文件\r\n\r\n\r\n后缀 .bz2\r\n解压命令: bzip2 -d InFile.bz2 或 bunzip2 InFile.bz2\r\n压缩命令: bzip2 -z InFile\r\n可压缩文件类型: 普通文件/打包文件\r\n\r\n\r\n后缀 .Z\r\n解压命令: uncompress InFile.Z\r\n压缩命令: compress InFile\r\n可压缩文件类型: 打包文件\r\n\r\n\r\n后缀 .rar\r\n解压命令: rar x InFile.rar\r\n压缩命令: rar a InFile\r\n可压缩文件类型: 文件夹/普通文件列表/打包文件', NULL, 'https://blog.csdn.net/zhangerqing/article/details/8609233');
INSERT INTO `blog` VALUES (307, 'Java之美[从菜鸟到高手演练]之Linux篇——Linux下比较重要的8个命令', '摘要:Linux里有很丰富的各种命令，有些是很难用的。然而，学会了前面说的这8个命令，你已经能处理大量的log分析任务了，完全不需要用脚本语言写程序来处理它们。每个程序员，在职业生...', '2018-12-11 23:14:43', '2018-12-11 23:24:24', 4, 1, 0, 7, '>	**摘要: **Linux里有很丰富的各种命令，有些是很难用的。然而，学会了前面说的这8个命令，你已经能处理大量的log分析任务了，完全不需要用脚本语言写程序来处理它们。\r\n\r\n每个程序员，在职业生涯的某个时刻，总会发现自己需要知道一些Linux方面的知识。我并不是说你应该成为一个Linux专家，我的意思是，当面对Linux命令行任务时，你应该能很熟练的完成。事实上，学会了下面8个命令，我基本上能完成任何需要完成的任务。\r\n\r\n注意：下面的每个命令都有十分丰富的文档说明。这篇文章并不是来详尽的展示每个命令的各种功用的。我在这里要讲的是这几个最常用的命令的最常见用法。如果你对linux命令并不是很了解，你想找一些这方面的资料学习，那这篇文章将会给你一个基本的指导。\r\n\r\n让我们从处理一些数据开始。假设我们有两个文件，分别记录的订单清单和订单处理结果。\r\n\r\n>	order.out.log  \r\n  8:22:19 111, 1, Patterns of Enterprise Architecture, Kindle edition, 39.99 \r\n  8:23:45 112, 1, Joy of Clojure, Hardcover, 29.99  \r\n  8:24:19 113, -1, Patterns of Enterprise Architecture, Kindle edition, 39.99 \r\n  order.in.log  \r\n  8:22:20 111, Order Complete  \r\n  8:23:50 112, Order sent to fulfillment  \r\n  8:24:20 113, Refund sent to processing \r\n\r\n#### cat -- 连接文件，并输出结果\r\n\r\ncat 命令非常的简单，你从下面的例子可以看到。\r\n\r\n>	jfields$ cat order.out.log   \r\n8:22:19 111, 1, Patterns of Enterprise Architecture, Kindle edition, 39.99  \r\n8:23:45 112, 1, Joy of Clojure, Hardcover, 29.99  \r\n8:24:19 113, -1, Patterns of Enterprise Architecture, Kindle edition, 39.99 \r\n\r\n就像它的说明描述的，你可以用它来连接多个文件。\r\n\r\n>	jfields$ cat order.*   \r\n8:22:20 111, Order Complete  \r\n8:23:50 112, Order sent to fulfillment  \r\n8:24:20 113, Refund sent to processing  \r\n8:22:19 111, 1, Patterns of Enterprise Architecture, Kindle edition, 39.99  \r\n8:23:45 112, 1, Joy of Clojure, Hardcover, 29.99  \r\n8:24:19 113, -1, Patterns of Enterprise Architecture, Kindle edition, 39.99 \r\n\r\n如果你想看这些log文件的内容，你可以把它们连接起来并输出到标准输出上，就是上面的例子展示的。这很有用，但输出的内容可以更有逻辑些。\r\n\r\n#### sort – 文件里的文字按行排序\r\n\r\n此时sort命令显然是你最佳的选择。\r\n\r\n>	jfields$ cat order.* | sort  \r\n8&#58:22:19 111, 1, Patterns of Enterprise Architecture, Kindle edition, 39.99  \r\n8:22:20 111, Order Complete  \r\n8:23:45 112, 1, Joy of Clojure, Hardcover, 29.99  \r\n8:23:50 112, Order sent to fulfillment  \r\n8:24:19 113, -1, Patterns of Enterprise Architecture, Kindle edition, 39.99  \r\n8:24:20 113, Refund sent to processing \r\n\r\n就像上面例子显示的，文件里的数据已经经过排序。对于一些小文件，你可以读取整个文件来处理它们，然而，真正的log文件通常有大量的内容，你不能不考虑这个情况。此时你应该考虑过滤出某些内容，把cat、sort后的内容通过管道传递给过滤工具。\r\n\r\n#### grep, egrep, fgrep – 打印出匹配条件的文字行\r\n\r\n假设我们只对Patterns of Enterprise Architecture这本书的订单感兴趣。使用grep，我们能限制只输出含有Patterns字符的订单。\r\n\r\n>	jfields$ cat order.* | sort | grep Patterns  \r\n8:22:19 111, 1, Patterns of Enterprise Architecture, Kindle edition, 39.99  \r\n8:24:19 113, -1, Patterns of Enterprise Architecture, Kindle edition, 39.99 \r\n\r\n假设退款订单113出了一些问题，你希望查看所有相关订单——你又需要使用grep了。\r\n\r\n>	jfields$ cat order.* | sort | grep \":\\d\\d 113, \"  \r\n8:24:19 113, -1, Patterns of Enterprise Architecture, Kindle edition, 39.99  \r\n8:24:20 113, Refund sent to processing \r\n\r\n你会发现在grep上的匹配模式除了“113”外还有一些其它的东西。这是因为113还可以匹配上书目或价格，加上额外的字符后，我们可以精确的搜索到我们想要的东西。\r\n\r\n现在我们已经知道了退货的详细信息，我们还想知道日销售和退款总额。但我们只关心《Patterns of Enterprise Architecture》这本书的信息，而且只关心数量和价格。我现在要做到是切除我们不关心的任何信息。\r\n\r\n#### cut – 删除文件中字符行上的某些区域\r\n\r\n又要使用grep，我们用grep过滤出我们想要的行。有了我们想要的行信息，我们就可以把它们切成小段，删除不需要的部分数据。\r\n\r\n>	jfields$ cat order.* | sort | grep Patterns  \r\n8:22:19 111, 1, Patterns of Enterprise Architecture, Kindle edition, 39.99  \r\n8:24:19 113, -1, Patterns of Enterprise Architecture, Kindle edition, 39.99  \r\n jfields$ cat order.* | sort | grep Patterns | cut -d\",\" -f2,5  \r\n 1, 39.99  \r\n -1, 39.99 \r\n \r\n 现在，我们把数据缩减为我们计算想要的形式，把这些数据粘贴到Excel里立刻就能得到结果了。\r\n\r\ncut是用来消减信息、简化任务的，但对于输出内容，我们通常会有更复杂的形式。假设我们还需要知道订单的ID，这样可以用来关联相关的其他信息。我们用cut可以获得ID信息，但我们希望把ID放到行的最后，用单引号包上。\r\n\r\n#### sed – 一个流编辑器。它是用来在输入流上执行基本的文本变换。\r\n\r\n下面的例子展示了如何用sed命令变换我们的文件行，之后我们在再用cut移除无用的信息。\r\n\r\n>	jfields$ cat order.* | sort | grep Patterns \\  \r\n>| sed s/\"[0-9\\:]* [0−9]∗[0−9]∗\\, .∗.∗\"/\"\\2, \'\\1\'\"/  \r\n1, Patterns of Enterprise Architecture, Kindle edition, 39.99, \'111\'  \r\n-1, Patterns of Enterprise Architecture, Kindle edition, 39.99, \'113\'  \r\n lmp-jfields01:~ jfields$ cat order.* | sort | grep Patterns \\  \r\n>| sed s/\"[0-9\\:]* [0−9]∗[0−9]∗\\, .∗.∗\"/\"\\2, \'\\1\'\"/ | cut -d\",\" -f1,4,5  \r\n1, 39.99, \'111\'  \r\n-1, 39.99, \'113\' \r\n\r\n我们对例子中使用的正则表达式多说几句，不过也没有什么复杂的。正则表达式做了下面几种事情\r\n\r\n- 删除时间戳\r\n- 捕捉订单号\r\n- 删除订单号后的逗号和空格\r\n- 捕捉余下的行信息\r\n\r\n里面的引号和反斜杠有点乱，但使用命令行时必须要用到这些。\r\n\r\n一旦捕捉到了我们想要的数据，我们可以使用 \\1 & \\2 来存储它们，并把它们输出成我们想要的格式。我们还在其中加入了要求的单引号，为了保持格式统一，我们还加入了逗号。最后，用cut命令把不必要的数据删除。\r\n\r\n现在我们有麻烦了。我们上面已经演示了如何把log文件消减成更简洁的订单形式，但我们的财务部门需要知道订单里一共有哪些书。\r\n\r\n#### uniq – 删除重复的行\r\n\r\n下面的例子展示了如何过滤出跟书相关的交易，删除不需要的信息，获得一个不重复的信息。\r\n\r\n>	jfields$ cat order.out.log | grep \"Kindle∥HardcoverKindle‖Hardcover\" | cut -d\",\" -f3 | sort | uniq -c  \r\n   1  Joy of Clojure  \r\n   2  Patterns of Enterprise Architecture \r\n\r\n看起来这是一个很简单的任务。\r\n\r\n这都是很好用的命令，但前提是你要能找到你想要的文件。有时候你会发现一些文件藏在很深的文件夹里，你根本不知道它们在哪。但如果你是知道你要寻找的文件的名字的话，这对你就不是个问题了。\r\n\r\n#### find – 在文件目录中搜索文件\r\n\r\n在上面的例子中我们处理了order.in.log和order.out.log这两个文件。这两个文件放在我的home目录里的。下面了例子将向大家展示如何在一个很深的目录结构里找到这样的文件。\r\n\r\n>	jfields$ find /Users -name \"order*\"  \r\nUsers/jfields/order.in.log  \r\nUsers/jfields/order.out.log \r\n\r\nfind命令有很多其它的参数，但99%的时间里我只需要这一个就够了。\r\n\r\n简单的一行，你就能找到你想要的文件，然后你可以用cat查看它，用cut修剪它。但文件很小时，你用管道把它们输出到屏幕上是可以的，但当文件大到超出屏幕时，你也许应该用管道把它们输出给less命令。\r\n\r\n#### less – 在文件里向前或向后移动\r\n\r\n让我们再回到简单的 cat | sort 例子中来，下面的命令就是将经过合并、排序后的内容输出到less命令里。在 less 命令，使用“/”来执行向前搜索，使用“？”命令执行向后搜索。搜索条件是一个正则表达式。\r\n\r\n>	jfields$ cat order* | sort | less \r\n\r\n如果你在 less 命令里使用 /113.*，所有113订单的信息都会高亮。你也可以试试?.*112，所有跟订单112相关的时间戳都会高亮。最后你可以用 ‘q’ 来退出less命令。\r\n\r\nLinux里有很丰富的各种命令，有些是很难用的。然而，学会了前面说的这8个命令，你已经能处理大量的log分析任务了，完全不需要用脚本语言写程序来处理它们。\r\n\r\n这篇文章是之前保存的网络上的一篇文章，遗憾的是已经不知道谁是作者了，所以，如果有侵权，请速与本人联系，定会协作妥善处理！', NULL, 'https://blog.csdn.net/zhangerqing/article/details/8545715>');
INSERT INTO `blog` VALUES (308, 'EasyUI分页的实现', '使用$.fn.pagination.defaults重写默认值对象该分页控件允许用户导航页面的数据。它支持页面导航和页面长度选择的选项设置。用户可以在分页控件上添加自定义按钮，以增...', '2018-12-11 23:54:15', '2018-12-12 16:57:31', 9, 4, 4, 6, '使用$.fn.pagination.defaults重写默认值对象\r\n\r\n该分页控件允许用户导航页面的数据。它支持页面导航和页面长度选择的选项设置。用户可以在分页控件上添加自定义按钮，以增强其功能。\r\n\r\n![](http://localhost:8081/static/userImage/2018/12/11/ec4fdd79-9fb3-422f-896c-43dd8ee9edbf.png)\r\n\r\n**使用案例**\r\n\r\n使用标签创建分页控件。\r\n\r\n```html\r\n<div id=\"pp\" class=\"easyui-pagination\" data-options=\"total:2000,pageSize:10\" style=\"background:#efefef;border:1px solid #ccc;\"></div> \r\n```\r\n\r\n使用Javascript创建分页控件\r\n\r\n```html\r\n<div id=\"pp\" style=\"background:#efefef;border:1px solid #ccc;\"></div> \r\n```\r\n\r\n```css\r\n$(\'#pp\').pagination({ \r\ntotal:2000, \r\npageSize:10 \r\n}); \r\n```\r\n让我们使用面板和分页插件来创建一个ajax分页。当用户选择一个新页面的时候，面板将显示指定页面的内容。\r\n\r\n```html\r\n<div id=\"content\" class=\"easyui-panel\" style=\"height:200px\" \r\ndata-options=\"href:\'show_content.php?page=1\'\"> \r\n</div> \r\n<div class=\"easyui-pagination\" style=\"border:1px solid #ccc;\" \r\n       data-options=\" \r\n    ).panel(\'refresh\', \'show_content.php?page=\'+pageNumber); \r\n}\"> \r\n</div> \r\n```\r\n\r\n面板上默认显示第一页的内容。当用户导航页面的时候，\'onSelectPage\'事件将被触发，将会根据一个新的URL参数获取对应页面的新内容，并通过\'refresh\'方法将内容刷新到内容面板上。\r\n\r\n**属性**\r\n\r\n![](/static/userImage/2018/12/11/75c506f6-6fdc-40e8-a077-87c925ed035e.png)\r\n\r\n![](/static/userImage/2018/12/11/0eaff45f-7416-4e3a-b175-7f524a6f9bea.png)\r\n\r\n**事件**\r\n\r\n![](/static/userImage/2018/12/11/55bf3019-5bf8-4f9a-8b7b-7d0624da42b3.png)\r\n\r\n**方法**\r\n\r\n![](/static/userImage/2018/12/11/f9a9acdd-e465-46fd-8c5a-28038b015c07.png)', '/static/userImage/2018/12/12/73b4ceb2-9d61-45d6-bfca-7c9715dc10fc.jpg', '');

-- ----------------------------
-- Table structure for blog_type
-- ----------------------------
DROP TABLE IF EXISTS `blog_type`;
CREATE TABLE `blog_type`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `type_name` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 11 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of blog_type
-- ----------------------------
INSERT INTO `blog_type` VALUES (5, 'Java');
INSERT INTO `blog_type` VALUES (6, '前端');
INSERT INTO `blog_type` VALUES (7, 'Linux');
INSERT INTO `blog_type` VALUES (8, '其他');
INSERT INTO `blog_type` VALUES (9, '数据库');
INSERT INTO `blog_type` VALUES (10, '算法');

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,
  `blog_id` int(11) UNSIGNED NOT NULL,
  `content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `comment_date` datetime NOT NULL,
  `state` int(1) NOT NULL,
  `visitor_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `visitor_ip` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `visitor_avatar` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `comment_ibfk_1`(`blog_id`) USING BTREE,
  CONSTRAINT `comment_ibfk_1` FOREIGN KEY (`blog_id`) REFERENCES `blog` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE = InnoDB AUTO_INCREMENT = 140 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of comment
-- ----------------------------
INSERT INTO `comment` VALUES (111, 271, '沙发要了', '2018-12-10 22:46:24', 1, '路人甲', '0:0:0:0:0:0:0:1', '/static/userImage/2018/12/10/e9de1dd0-7a1b-46d9-a01d-49fb0e073f56.jpg');
INSERT INTO `comment` VALUES (121, 271, '[em_24]', '2018-12-11 14:00:54', 1, 'Interval测试', '0:0:0:0:0:0:0:1', '/static/userImage/2018/12/11/a1906ffd-c409-488d-b979-8a48e1327311.jpg');
INSERT INTO `comment` VALUES (126, 299, '转载测试', '2018-12-11 14:34:15', 1, '转载测试', '0:0:0:0:0:0:0:1', '/static/userImage/2018/12/11/922a0f12-e769-4256-9e82-decb73105bfc.jpg');
INSERT INTO `comment` VALUES (127, 308, '图片上传测试[em_5]', '2018-12-12 13:20:50', 1, '渣渣辉', '0:0:0:0:0:0:0:1', '/static/userImage/2018/12/12/0856f23f-fc11-4c15-b8a7-a0d2c76d6aad.jpg');
INSERT INTO `comment` VALUES (128, 308, '还是测试', '2018-12-12 13:36:26', 1, '是兄弟就来砍我', '0:0:0:0:0:0:0:1', '/static/userImage/2018/12/12/4059c431-e6d7-40d8-b51d-e12a497cacfc.jpg');
INSERT INTO `comment` VALUES (129, 308, '😁', '2018-12-12 13:37:32', 1, '是兄弟就来砍我', '0:0:0:0:0:0:0:1', '/static/userImage/2018/12/12/4059c431-e6d7-40d8-b51d-e12a497cacfc.jpg');
INSERT INTO `comment` VALUES (137, 307, 'cookie 测试[em_17]', '2018-12-12 14:00:01', 1, 'It\'s me', '0:0:0:0:0:0:0:1', '/static/userImage/2018/12/12/29648064-3487-433b-a074-06a730152033.jpg');
INSERT INTO `comment` VALUES (138, 308, '啦啦啦', '2018-12-12 17:04:58', 1, '在线评论', '0:0:0:0:0:0:0:1', '/static/userImage/2018/12/12/475c1792-c4a3-4663-b86f-8b9bec69ef6e.jpg');

-- ----------------------------
-- Table structure for link
-- ----------------------------
DROP TABLE IF EXISTS `link`;
CREATE TABLE `link`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,
  `link_name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `link_url` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `link_order` int(11) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 11 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of link
-- ----------------------------
INSERT INTO `link` VALUES (8, '阿里巴巴矢量图库', 'http://www.iconfont.cn/', 1);
INSERT INTO `link` VALUES (9, 'Github', 'https://github.com/', 2);
INSERT INTO `link` VALUES (10, 'w3cschool', 'https://www.w3cschool.cn/', 3);

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,
  `username` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `password` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `profile` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `avatar` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES (1, 'admin', '3facf26687dab7254848976256edb56f', '# 稳就是了', '/static/userImage/2018/12/09/c36aed0d-2335-4aee-9d10-6d44350dc6c7.jpg');

SET FOREIGN_KEY_CHECKS = 1;
